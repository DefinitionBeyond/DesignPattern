静态代理：
        优点：业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。
        缺点：
        1）代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。
        2）如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。


动态代理：
        适用场景：
        日志集中打印
        事物
        权限管理
        Spring AOP

        优点：
        动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。
        这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。
        在本示例中看不出来，因为invoke方法体内嵌入了具体的外围业务（记录任务处理前后时间并计算时间差），实际中可以类似Spring AOP那样配置外围业务。


        缺点：
        诚然，Proxy已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。
        回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。
        Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通。
        有很多条理由，人们可以否定对 class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。
        接口和类的划分，本就不是很明显，只是到了Java中才变得如此的细化。如果只从方法的声明及是否被定义来考量，
        有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。
        此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。
        如此种种，不得不说是一个小小的遗憾。但是，不完美并不等于不伟大，伟大是一种本质，Java动态代理就是佐例。


cglib：
        优点：
        打破了动态代理的时候，代理对象只能是接口，代理对象不能是类。

        模拟实现cglib的时候需要cglib jar 和动态代理增强器的asm jar(如何没有这些jar，可以通过maven下载)

        Spring aop 底层实现是通过反射的一个代理过程，代理的对象是接口时候，就是jdk的proxy
        代理是对象的时候，就是cglib

        mybatis很多地方也采用的是cglib

在Spring AOP当中可以哪些方式实现和区别：
        JDK Proxy(动态构建字节码)(生成一个全新的代理class)

        cglib(动态构建字节码)(生成一个全新的代理class)

        Aspectj (修改目标类的字节码，植入代理的字节，在程序中编译)(直接修改目标class)

        instrumentation (修改目标类的字节码,类装载的时候动态拦截去修改，基于javaagent)(直接修改目标class)

    对于以上4种实现方式：
        JDK Proxy 和 cglib 易于实现

        Aspectj 和 instrumentation 实现性能高，但是代价大


动态代理的本质过程均是Class字节码的构建和修改 :
    修改的工具有ASM，javassist

多种实现方式的区别在于对字节码的切入方式不同，可选方式有：
        JDK Proxy ，cglib 是基于动态构建字节码

        Aspectj 是借助idea，eclipse编译工具在编译时候植入代理的字节码

        instrumentation 是基于javaagent在类装载的时候修改Class 植入代理字节码

        使用自定义ClassLoader在装载的时候植入字节码



